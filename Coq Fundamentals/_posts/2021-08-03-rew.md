---
layout: post
title: "Coq Fundamentals: Equality III"
date: 2021-08-03 00:00:03
tag: Coq
---

## Rewrite

 Last time, we showed how to use `eq_ind` to manually prove inequalities. `eq_ind` is the 
   inductive principle automatically generated by Coq based on the inductive definition of 
   Coq. In the spirit of our deep dive, let's take a look at the underlying definition.
 
{% highlight Coq %}
Print eq_ind.

(* eq_ind = 
   fun (A : Type) (x : A) (P : A -> Prop) (f : P x) (y : A) (e : x = y) =>
   match e in (_ = y0) return (P y0) with
   | eq_refl => f
   end
   : forall (A : Type) (x : A) (P : A -> Prop),
       P x -> forall y : A, x = y -> P 
 *)
{% endhighlight %}


 As we can see, the definition is actually quite trivial. We are only returning the 
   `f` argument. The "magic" is done by the `in` and `return` clauses of the match 
   statement, which types the expression using the right hand side of the equality 
   instead of the left.

   Notice that `P` is a predicate, i.e. it maps the value in the equality to a Prop. 
   There is no reason this must be the case. In addition to generating the inductive 
   principle "_ind", Coq will also generate the corresponding recursive principle 
   "_rec" for Set-valued functions, and the fully general Type-recursive principle 
   "_rect" for Type-valued functions.
 
{% highlight Coq %}
Check eq_rect.

(* eq_rect
	 : forall (A : Type) (x : A) (P : A -> Type),
       P x -> forall y : A, x = y -> P y
 *)
{% endhighlight %}


 If you squint at this type just right, it may start to look like substitution. Indeed, 
   we can use `eq_rect` to perform rewriting by hand. Let's take a look at a proof of the 
   transitivity of equality.
 
{% highlight Coq %}
Theorem eq_trans {A}: forall x y z: A,
  x = y ->
  y = z -> 
  x = z.
Proof using.
  intros * eq_xy eq_yz.
{% endhighlight %}


 Normally, we would use the rewrite tactic from here. 
{% highlight Coq %}
  rewrite eq_xy.
{% endhighlight %}


 At this point, we'd finish the proof by `assumption`. But let's try to do this step
   manually.

{% highlight Coq %}
  Undo.
  eapply (eq_rect _ _ eq_xy).
{% endhighlight %}


 Perfect! 
{% highlight Coq %}
  assumption.
Qed.
{% endhighlight %}


 This last example was perhaps decievingly simple though. Let's try rewriting when the 
   goal is not itself an equality.

{% highlight Coq %}
Theorem one_gt_0: forall x, x = 1 -> x > 0.
Proof using.
  intros * eq.
  Fail eapply (eq_rect _ _ eq).

(* The command has indeed failed with message:
   In environment
   x : nat
   eq : x = 1
   Unable to unify "x = ?M160" with "1 <= x"
 *)
{% endhighlight %}


 The problem is that Coq cannot assume the argument `P: nat -> Type`. We can easily solve
   this by making it apparent in the goal. We do this with the `pattern` tactic, "factoring out"
   the `x` by beta expansion.
 
{% highlight Coq %}
  pattern x.
  Check (eq_rect _ (fun n => n > 0)).

(* eq_rect ?x (fun n : nat => n > 0)
	    : ?x > 0 -> forall y : nat, ?x = y -> y > 0
   where
   ?x : [x : nat  eq : x = 1 |- nat
 *)
{% endhighlight %}


 Note that eq_rect doesn't quite do what we want here, because it expects a hypothesis 
   of the form `?x = y`, when our's is in the form `y = ?x`. Instead, we use `eq_rect`'s 
   sister, `eq_rect_r`.
 
{% highlight Coq %}
  eapply (eq_rect_r _).
{% endhighlight %}


 This is almost what we want, but the order of the arguments prevents us from giving 
   the rewrite equality. We solve the problem by instead passing a function with the 
   new goal argument stubbed out.
 
{% highlight Coq %}
  Undo.
  apply (fun new_goal => eq_rect_r _ new_goal eq).
{% endhighlight %}


 We did it! 
{% highlight Coq %}
  intuition.
Qed.
{% endhighlight %}


# Detour 

 Now that we think we know the general approach to rewriting, why don't we try to properly 
   generalize it by writing our own rewrite tactic?
 

{% highlight Coq %}
Ltac is_in_goal x :=
  match goal with 
  | |- context[x] => idtac
  end.

Ltac rew_r H :=
  match type of H with 
  | ?x = _ => 
      (is_in_goal x + fail "Nothing to rewrite");
      pattern x;
      apply (fun new_goal => eq_rect_r _ new_goal H)
  end.

Goal forall x, x = 1 -> x > 0.
  intros * H.
  rew_r H.
(* Looks good! *)
Abort.
{% endhighlight %}


 To rewrite in the other direction, we return to `eq_rect`. Note that `eq_rect` has less 
   implicit arguments then `eq_rect_r`, so confusingly we must add more holes
 
{% highlight Coq %}
Ltac rew_l H :=
  match type of H with 
  | _ = ?y => 
      (is_in_goal y + fail "Nothing to rewrite");
      pattern y;
      apply (fun new_goal => eq_rect _ _ new_goal _ H)
  end.
 
Goal forall x, 1 = x -> x > 0.
  intros * H.
  rew_l H.
(* Awesome! *)
Abort.
{% endhighlight %}


 The core functionality is there, now we add in some convenient notation and error messaging.
 

{% highlight Coq %}
Ltac is_an_equality H :=
  match type of H with 
  | _ = _ => idtac
  end.

Tactic Notation "rew" "->" uconstr(H) :=
  (is_an_equality H + fail "Not an equality");
  rew_r H.

Tactic Notation "rew" "<-" hyp(H) :=
  (is_an_equality H + fail "Not an equality");
  rew_l H.

Tactic Notation "rew" hyp(H) :=
  rew -> H +
  rew <- H.

Goal forall x y: nat, x = y -> ~ x > y.
  intros * eq.
  rew eq.
  Undo.
  rew -> eq.
  Undo.
  rew <- eq.
  assert (H: x = 1) by admit.
  Fail rew <- H.
  assert (H': x > 1) by admit.
  Fail rew H'.
Abort.
{% endhighlight %}

 
 This is almost just as good as the standard `rewrite` tactic! The one thing we
   haven't done is handled rewriting in a hypothesis. This involves forward instead 
   of backwards reasoning, but the key ideas are the same. I'll leave it as my first 
   suggested excercise to the reader.

   Up next, inversion!

